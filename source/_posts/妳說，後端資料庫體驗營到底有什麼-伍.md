---
title: 妳說，後端資料庫體驗營到底有什麼? 伍
date: 2024-11-28 23:58:55
tags: Practice
description: 但本來，那就是所謂體驗營不是嗎？那就是所謂的人生不是嗎？
---
終

### 學生國文、數學、英文成績

![table0](https://firebasestorage.googleapis.com/v0/b/pictureforu-3b8e9.appspot.com/o/SQL%20%3A%2020241129%20Practice%2Fdownload%20(2).png?alt=media&token=afabed70-8d2e-4f35-b738-0e48051c2015)

資料表與模擬資料
1. subject ：科目名稱
2. exam_score：科目成績
3. student：學生資料

<font color=#0000FF> ln [0]: </font>

```sql
-- 建立資料表
CREATE TABLE student (
 id serial PRIMARY KEY,
 name varchar(50) NOT NULL,
 class varchar(20) NOT NULL,
 created_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE subject (
 id serial PRIMARY KEY,
 name varchar(50) NOT NULL,
 created_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE exam_score (
 id serial PRIMARY KEY,
 student_id integer NOT NULL,
 subject_id integer NOT NULL,
 score integer NOT NULL,
 exam_date date NOT NULL,
 created_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
 FOREIGN KEY (student_id) REFERENCES student(id),
 FOREIGN KEY (subject_id) REFERENCES subject(id)
);

-- 插入測試資料
INSERT INTO student (name, class) VALUES
('小明', '三年一班'),
('小華', '三年一班'),
('小美', '三年一班'),
('小龍', '三年一班'),
('小智', '三年一班');

INSERT INTO subject (name) VALUES
('國文'),
('英文'),
('數學');

INSERT INTO exam_score (student_id, subject_id, score, exam_date) VALUES
(1, 1, 85, '2024-03-01'),
(1, 2, 92, '2024-03-01'),
(1, 3, 78, '2024-03-01'),
(2, 1, 76, '2024-03-01'),
(2, 2, 88, '2024-03-01'),
(2, 3, 95, '2024-03-01'),
(3, 1, 92, '2024-03-01'),
(3, 2, 85, '2024-03-01'),
(3, 3, 87, '2024-03-01'),
(4, 1, 78, '2024-03-01'),
(4, 2, 82, '2024-03-01'),
(4, 3, 90, '2024-03-01'),
(5, 1, 88, '2024-03-01'),
(5, 2, 79, '2024-03-01'),
(5, 3, 93, '2024-03-01');
```

<font color=#FF0000> Out [0]:  </font>

![0](https://firebasestorage.googleapis.com/v0/b/pictureforu-3b8e9.appspot.com/o/SQL%20%3A%2020241128%20Practice%2F0.png?alt=media&token=6fbefb20-01aa-4f4b-8cdf-246d392818a0)

這段 SQL 程式碼的目的是建立一個簡單的學生成績管理系統，包含三張資料表（student、subject、exam_score），並插入測試資料。

**建立資料表**
1. 學生表：student

```sql
CREATE TABLE student (
 id serial PRIMARY KEY,                          -- 自動遞增的主鍵，用於唯一標識每個學生
 name varchar(50) NOT NULL,                     -- 學生姓名，最多 50 個字元，且不可為空
 class varchar(20) NOT NULL,                    -- 學生班級，最多 20 個字元，且不可為空
 created_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP -- 建立時間，預設為當前時間
);
```
>用途：儲存學生的基本資訊，包括學生的 ID、姓名、班級和建立時間。
><code>serial</code>：自動生成唯一的 ID。
>NOT NULL：確保欄位值不可為空。

2. 科目表：subject

```sql
CREATE TABLE subject (
 id serial PRIMARY KEY,                          -- 自動遞增的主鍵，用於唯一標識每個科目
 name varchar(50) NOT NULL,                     -- 科目名稱，最多 50 個字元，且不可為空
 created_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP -- 建立時間，預設為當前時間
);
```
>用途：儲存科目的基本資訊，包括科目 ID 和名稱。

3. 成績表：exam_score

```sql
CREATE TABLE exam_score (
 id serial PRIMARY KEY,                          -- 自動遞增的主鍵，用於唯一標識每筆成績記錄
 student_id integer NOT NULL,                   -- 學生 ID，對應到 `student` 表的主鍵
 subject_id integer NOT NULL,                   -- 科目 ID，對應到 `subject` 表的主鍵
 score integer NOT NULL,                        -- 成績，整數，且不可為空
 exam_date date NOT NULL,                       -- 考試日期，格式為日期型別
 created_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, -- 建立時間，預設為當前時間
 FOREIGN KEY (student_id) REFERENCES student(id), -- 外鍵，關聯到學生表的 ID
 FOREIGN KEY (subject_id) REFERENCES subject(id)  -- 外鍵，關聯到科目表的 ID
);
```
>用途：儲存學生的考試成績，包括學生、科目、分數和考試日期。
><code>FOREIGN KEY</code>：建立外鍵約束，確保 student_id 和 subject_id 的值必須存在於對應的表中。

**插入測試資料**
1. 插入學生資料

```sql
INSERT INTO student (name, class) VALUES
('小明', '三年一班'),
('小華', '三年一班'),
('小美', '三年一班'),
('小龍', '三年一班'),
('小智', '三年一班');
```

2. 插入科目資料

```sql
INSERT INTO subject (name) VALUES
('國文'),
('英文'),
('數學');
```

3. 插入成績資料

```sql
INSERT INTO exam_score (student_id, subject_id, score, exam_date) VALUES
(1, 1, 85, '2024-03-01'),
(1, 2, 92, '2024-03-01'),
(1, 3, 78, '2024-03-01'),
(2, 1, 76, '2024-03-01'),
(2, 2, 88, '2024-03-01'),
(2, 3, 95, '2024-03-01'),
(3, 1, 92, '2024-03-01'),
(3, 2, 85, '2024-03-01'),
(3, 3, 87, '2024-03-01'),
(4, 1, 78, '2024-03-01'),
(4, 2, 82, '2024-03-01'),
(4, 3, 90, '2024-03-01'),
(5, 1, 88, '2024-03-01'),
(5, 2, 79, '2024-03-01'),
(5, 3, 93, '2024-03-01');
```

>插入了每位學生在每個科目的成績，考試日期為 2024-03-01。

>數據解釋：
>>學生 ID 對應到 student 表，例如：
>>>1 表示小明
>>>2 表示小華
>>>3 表示小美
>>>4 表示小龍
>>>5 表示小智

>>科目 ID 對應到 subject 表，例如：
>>>1 表示國文
>>>2 表示英文
>>>3 表示數學

>成績為每位學生在對應科目中的分數。

**注意事項**
1. 外鍵約束：
    + student_id 和 subject_id 必須在 student 和 subject 表中存在，否則插入會失敗。
2. 自動生成時間戳：
    + created_at 欄位會自動記錄資料建立的時間。

**Q1 計算每個學生的總分**
要計算每個學生的總分，可以使用 SQL 的 SUM 函數來對每個學生的成績進行加總，並使用 GROUP BY 按照學生的 ID 或姓名分組。

<font color=#0000FF> ln [1]: </font>

```sql
SELECT
    s.name AS student_name,           -- 學生姓名
    SUM(e.score) AS total_score       -- 總分
FROM
    exam_score e                      -- 成績表
JOIN
    student s                         -- 與學生表聯結
ON
    e.student_id = s.id               -- 聯結條件：成績表中的 student_id 對應學生表的 id
GROUP BY
    s.name                            -- 按學生姓名分組
ORDER BY
    total_score DESC;                 -- 按總分降序排列
```

<font color=#FF0000> Out [1]:  </font>

![1](https://firebasestorage.googleapis.com/v0/b/pictureforu-3b8e9.appspot.com/o/SQL%20%3A%2020241129%20Practice%2F1.png?alt=media&token=91e5c3ef-dae6-45d3-8525-8bdcc0baea97)

>SUM(e.score)：
>>使用 SUM 函數將每位學生的所有科目成績加總，計算總分。

>GROUP BY s.name：
>>按學生姓名分組，確保每位學生的成績被正確加總到一起。

><code>JOIN</code>：
>>將 exam_score 表與 student 表聯結，通過 student_id 對應到學生的姓名。

><code>ORDER BY total_score DESC</code>：
>>按照總分從高到低排序，方便查看成績排名。

**Q2 計算每科的平均分數並依分數排序**
計算每科的平均分數並根據分數排序，可以使用 SQL 的 AVG 函數來計算平均值，再使用 <code>GROUP BY</code>按科目分組。

<font color=#0000FF> ln [2]: </font>

```sql
SELECT
    sub.name AS subject_name,         -- 科目名稱
    ROUND(AVG(e.score), 2) AS avg_score -- 平均分數，保留兩位小數
FROM
    exam_score e                      -- 成績表
JOIN
    subject sub                       -- 與科目表聯結
ON
    e.subject_id = sub.id             -- 聯結條件：成績表中的 subject_id 對應科目表的 id
GROUP BY
    sub.name                          -- 按科目名稱分組
ORDER BY
    avg_score DESC;                   -- 按平均分數降序排列
```

<font color=#FF0000> Out [2]:  </font>

![2](https://firebasestorage.googleapis.com/v0/b/pictureforu-3b8e9.appspot.com/o/SQL%20%3A%2020241129%20Practice%2F2.png?alt=media&token=27e53589-28bf-47db-ae95-fc701da91456)

>AVG(e.score)：
>>使用 AVG 函數計算每個科目的平均分數。

>ROUND(AVG(e.score), 2)：
>>使用 ROUND 函數將平均分數保留兩位小數，讓結果更精確且美觀。

>GROUP BY sub.name：
>>按科目名稱分組，確保每個科目的分數被正確計算平均值。

>ORDER BY avg_score DESC：
>>按平均分數從高到低排序，方便查看哪一科的平均分數最高。

**Q3 顯示英文成績排名**
顯示「英文」科目的成績排名，可以根據科目名稱篩選出英文的成績，然後按分數排序即可。

<font color=#0000FF> ln [3]: </font>

```SQL
SELECT
    s.name AS student_name,           -- 學生姓名
    e.score AS english_score          -- 英文成績
FROM
    exam_score e
JOIN
    student s                         -- 成績表與學生表聯結
ON
    e.student_id = s.id
JOIN
    subject sub                       -- 成績表與科目表聯結
ON
    e.subject_id = sub.id
WHERE
    sub.name = '英文'                 -- 篩選科目為「英文」
ORDER BY
    e.score DESC;                     -- 按英文成績降序排列
```

<font color=#FF0000> Out [3]:  </font>

![3](https://firebasestorage.googleapis.com/v0/b/pictureforu-3b8e9.appspot.com/o/SQL%20%3A%2020241129%20Practice%2F3.png?alt=media&token=f0aebcb1-76bd-4ddd-bc65-243c191359da)

>WHERE sub.name = '英文'：
>>使用 WHERE 條件篩選出科目名稱為「英文」的成績。

>ORDER BY e.score DESC：
>>按照英文成績從高到低排序，顯示成績排名。

><code>JOIN</code>：
>分別將 exam_score 表與 student 表、subject 表聯結，這樣可以獲取學生姓名和科目名稱。

**Q4 找出考最好的科目**
考最好 === 分數最高
要找出分數最高的科目，可以計算每個科目的最高分，並選出分數最高的那一科。

<font color=#0000FF> ln [4]: </font>

```sql
SELECT
    sub.name AS subject_name,         -- 科目名稱
    MAX(e.score) AS highest_score     -- 該科目的最高分
FROM
    exam_score e
JOIN
    subject sub                       -- 成績表與科目表聯結
ON
    e.subject_id = sub.id
GROUP BY
    sub.name                          -- 按科目名稱分組
ORDER BY
    highest_score DESC                -- 按最高分降序排列
LIMIT 1;                              -- 只取最高分的那一科
```

<font color=#FF0000> Out [4]:  </font>

![4](https://firebasestorage.googleapis.com/v0/b/pictureforu-3b8e9.appspot.com/o/SQL%20%3A%2020241129%20Practice%2F4.png?alt=media&token=7a699a92-d67f-493f-bc61-8635af58ad3b)

>MAX(e.score)：
>>使用 MAX 函數計算每個科目的最高分。

>GROUP BY sub.name：
>>按科目名稱分組，確保每科的最高分被正確計算。

>ORDER BY highest_score DESC：
>>按最高分從高到低排序，確保分數最高的科目排在第一位。

>LIMIT 1：
>>只取出排序後的第一條記錄，即分數最高的科目。

**Q5 計算每位學生的總分和全班平均的差距，依總分排序**
計算每位學生的總分，然後計算他們的總分與全班平均總分的差距，最後再依總分排序。

<font color=#0000FF> ln [5]: </font>

```SQL
WITH student_total AS (
---- 計算每位學生的總分 ----
    SELECT
        s.name AS student_name,       -- 學生姓名
        SUM(e.score) AS total_score  -- 每位學生的總分
    FROM
        exam_score e
    JOIN
        student s
    ON
        e.student_id = s.id
    GROUP BY
        s.name
),
class_avg AS (
---- 計算全班的平均總分 ----
    SELECT
        AVG(total_score) AS avg_total_score
    FROM
        student_total
)
---- 計算每位學生與全班平均總分的差距 ----
SELECT
    st.student_name,                  -- 學生姓名
    st.total_score,                   -- 每位學生的總分
    ROUND(st.total_score - ca.avg_total_score, 2) AS score_difference -- 與平均分的差距
FROM
    student_total st
CROSS JOIN
    class_avg ca
ORDER BY
    st.total_score DESC;              -- 按總分降序排列
```

<font color=#FF0000> Out [5]:  </font>

![5](https://firebasestorage.googleapis.com/v0/b/pictureforu-3b8e9.appspot.com/o/SQL%20%3A%2020241129%20Practice%2F5.png?alt=media&token=e72b4384-c631-4574-9f35-9dc11e20f79b)

>WITH student_total AS (...)：
>>使用子查詢計算每位學生的總分，並將結果暫存為 student_total 表。
>>使用 SUM(e.score) 將該學生的所有科目成績相加。

>WITH class_avg AS (...)：
>>使用子查詢計算全班的平均總分，並將結果暫存為 class_avg 表。
>>使用 AVG(total_score) 計算所有學生總分的平均值。

><code>CROSS JOIN</code>：
>>將每位學生的總分與全班的平均總分進行組合，以計算差距。

>ROUND(st.total_score - ca.avg_total_score, 2)：
>>計算每位學生的總分與全班平均總分的差距，並保留兩位小數。

>ORDER BY st.total_score DESC：
>>按學生的總分從高到低排序，方便查看排名。

<font color=#c0c0c0> ＨＥＬＬＯ 您好嗎？  </font>
<font color=#c0c0c0> 衷心感謝，期待再相逢。  </font>